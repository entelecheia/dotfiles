#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Function to display error messages and exit
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Function to display warning messages
warn() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

# Function to display success messages
success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to display usage information
usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS] [input_file]

Convert Poetry pyproject.toml to UV format.

Options:
  -h, --help     Show this help message and exit
  -f, --force    Force overwrite of existing output file
  --no-backup    Skip creating backup file

Arguments:
  input_file     Path to pyproject.toml (defaults to ./pyproject.toml)
EOF
    exit 1
}

# Function to check if required commands exist
check_requirements() {
    local missing_commands=()
    for cmd in rsync grep sed awk; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_commands+=("$cmd")
        fi
    done

    if [ ${#missing_commands[@]} -ne 0 ]; then
        error "Required commands not found: ${missing_commands[*]}"
    fi
}

# Function to extract metadata from pyproject.toml
extract_metadata() {
    local content="$1"
    local -n metadata=$2

    # Extract basic metadata
    metadata[name]=$(echo "$content" | grep '^name = ' | cut -d '"' -f 2)
    metadata[version]=$(echo "$content" | grep '^version = ' | cut -d '"' -f 2)
    metadata[description]=$(echo "$content" | grep '^description = ' | cut -d '"' -f 2)
    metadata[homepage]=$(echo "$content" | grep '^homepage = ' | cut -d '"' -f 2)
    metadata[repository]=$(echo "$content" | grep '^repository = ' | cut -d '"' -f 2)
    metadata[license]=$(echo "$content" | grep '^license = ' | cut -d '"' -f 2)

    # Extract author information
    local authors_line
    authors_line=$(echo "$content" | grep '^authors = ')
    metadata[author_name]=$(echo "$authors_line" | sed 's/.*\["\(.*\) <.*/\1/')
    metadata[author_email]=$(echo "$authors_line" | sed 's/.*<\(.*\)>.*/\1/')

    # Extract Python version
    metadata[python_version]=$(echo "$content" | grep '^python = ' | awk '{
        output = $3
        gsub(/^"/, "", output)
        gsub(/"$/, "", output)
        if (match(output, /^[[:alnum:]]/)) {
            output = "==" output
        } else {
            gsub(/^[^[:alnum:]]+/, "", output)
            output = ">=" output
        }
        print output
    }')

    # Validate required fields
    local required_fields=("name" "version" "description" "author_name" "author_email" "python_version")
    for field in "${required_fields[@]}"; do
        if [ -z "${metadata[$field]:-}" ]; then
            error "Required field '$field' not found in pyproject.toml"
        fi
    done
}

# Function to clean up dependency lines
clean_dependency() {
    local line="$1"
    if echo "$line" | grep -q 'path\s*=\s*'; then
        echo "$line" | sed -e 's/^.*\s=\s{/# {/g'
    elif echo "$line" | grep -q 'extras'; then
        echo "$line" | sed -e 's/\s=\s//g' \
            -e 's/{.*extras.*\(\[.*\]\).*version"^\(.*\)}/\1>=\2/' \
            -e 's/\"//g' \
            -e 's/^/"/;s/$/"/'
    else
        echo "$line" | sed -e 's/\s=\s\"^/>=/g' \
            -e 's/\"//' \
            -e 's/^/"/;s/$/"/'
    fi
}

# Function to extract and format dependencies
extract_dependencies() {
    local content="$1"
    local section="$2"
    local end_pattern="$3"

    echo "$content" |
        sed -n "/$section/,/$end_pattern/p" |
        sed -e '1d; $d' |
        grep -v '^$' |
        sort |
        while read -r line; do
            cleaned=$(clean_dependency "$line")
            [ -n "$cleaned" ] && echo "    $cleaned,"
        done
}

# Parse command line arguments
force=false
create_backup=true
input_file="pyproject.toml"

while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
        usage
        ;;
    -f | --force)
        force=true
        shift
        ;;
    --no-backup)
        create_backup=false
        shift
        ;;
    *)
        if [ -n "${2:-}" ]; then
            error "Unknown argument: $1"
        fi
        input_file="$1"
        shift
        ;;
    esac
done

# Check requirements
check_requirements

# Validate input file
[ -f "$input_file" ] || error "Input file '$input_file' not found"
grep -q '\[tool\.poetry\.dependencies\]' "$input_file" || error "Input file is not a Poetry pyproject.toml"

# Setup paths
full_path=$(realpath "$input_file")
dir_path=$(dirname "$full_path")
output_file="${dir_path}/pyproject.toml"
backup_file="${dir_path}/pyproject.toml.old"

# Create backup if needed
if [ "$create_backup" = true ]; then
    if ! rsync -a "$input_file" "$backup_file"; then
        error "Failed to create backup file"
    fi
    success "Backup created: $backup_file"
fi

# Read content and extract metadata
content=$(cat "$input_file")
declare -A metadata
extract_metadata "$content" metadata

# Extract dependencies
dependencies=$(extract_dependencies "$content" "\[tool.poetry.dependencies\]" "\[tool\.poetry\.group\.dev")
dev_dependencies=$(extract_dependencies "$content" "\[tool.poetry.group.dev.dependencies\]" "\[")

# Create output file
if [ -f "$output_file" ] && [ "$force" = false ]; then
    error "Output file already exists. Use -f to force overwrite."
fi

cat <<EOF >"$output_file"
[project]
name = "${metadata[name]}"
version = "${metadata[version]}"
description = "${metadata[description]}"
requires-python = "${metadata[python_version]}"
readme = "README.md"
license = {text = "${metadata[license]:-MIT}"}
authors = [{name = "${metadata[author_name]}", email = "${metadata[author_email]}"}]
urls = {
    homepage = "${metadata[homepage]:-}",
    repository = "${metadata[repository]:-}"
}
dependencies = [
$dependencies
]

[tool.uv]
dev-dependencies = [
$dev_dependencies
]

# Preserve existing tool configurations from the original file
$(echo "$content" | sed -n '/\[tool\./,$ p' | grep -v '\[tool\.poetry')
EOF

success "Successfully converted to UV format: $output_file"
